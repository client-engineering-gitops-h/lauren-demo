{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/lauren/lauren-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/lauren/lauren-demo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.assertEach = assertEach;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertNodeType = assertNodeType;\nexports.assertOneOf = assertOneOf;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.assertShape = assertShape;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports[\"default\"] = defineType;\nexports.defineAliasedType = defineAliasedType;\nexports.typeIs = typeIs;\nexports.validate = validate;\nexports.validateArrayOfType = validateArrayOfType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.validateType = validateType;\n\nvar _is = require(\"../validators/is\");\n\nvar _validate = require(\"../validators/validate\");\n\nvar VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nvar ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nvar FLIPPED_ALIAS_KEYS = {};\nexports.FLIPPED_ALIAS_KEYS = FLIPPED_ALIAS_KEYS;\nvar NODE_FIELDS = {};\nexports.NODE_FIELDS = NODE_FIELDS;\nvar BUILDER_KEYS = {};\nexports.BUILDER_KEYS = BUILDER_KEYS;\nvar DEPRECATED_KEYS = {};\nexports.DEPRECATED_KEYS = DEPRECATED_KEYS;\nvar NODE_PARENT_VALIDATIONS = {};\nexports.NODE_PARENT_VALIDATIONS = NODE_PARENT_VALIDATIONS;\n\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\n\nfunction validate(validate) {\n  return {\n    validate: validate\n  };\n}\n\nfunction typeIs(typeName) {\n  return typeof typeName === \"string\" ? assertNodeType(typeName) : assertNodeType.apply(void 0, _toConsumableArray(typeName));\n}\n\nfunction validateType(typeName) {\n  return validate(typeIs(typeName));\n}\n\nfunction validateOptional(validate) {\n  return {\n    validate: validate,\n    optional: true\n  };\n}\n\nfunction validateOptionalType(typeName) {\n  return {\n    validate: typeIs(typeName),\n    optional: true\n  };\n}\n\nfunction arrayOf(elementType) {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nfunction arrayOfType(typeName) {\n  return arrayOf(typeIs(typeName));\n}\n\nfunction validateArrayOfType(typeName) {\n  return validate(arrayOfType(typeName));\n}\n\nfunction assertEach(callback) {\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n\n    for (var i = 0; i < val.length; i++) {\n      var subkey = \"\".concat(key, \"[\").concat(i, \"]\");\n      var v = val[i];\n      callback(node, subkey, v);\n      if (process.env.BABEL_TYPES_8_BREAKING) (0, _validate.validateChild)(node, subkey, v);\n    }\n  }\n\n  validator.each = callback;\n  return validator;\n}\n\nfunction assertOneOf() {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  function validate(node, key, val) {\n    if (values.indexOf(val) < 0) {\n      throw new TypeError(\"Property \".concat(key, \" expected value to be one of \").concat(JSON.stringify(values), \" but got \").concat(JSON.stringify(val)));\n    }\n  }\n\n  validate.oneOf = values;\n  return validate;\n}\n\nfunction assertNodeType() {\n  for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    types[_key2] = arguments[_key2];\n  }\n\n  function validate(node, key, val) {\n    var _iterator = _createForOfIteratorHelper(types),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var type = _step.value;\n\n        if ((0, _is[\"default\"])(type, val)) {\n          (0, _validate.validateChild)(node, key, val);\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    throw new TypeError(\"Property \".concat(key, \" of \").concat(node.type, \" expected node to be of a type \").concat(JSON.stringify(types), \" but instead got \").concat(JSON.stringify(val == null ? void 0 : val.type)));\n  }\n\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\n\nfunction assertNodeOrValueType() {\n  for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    types[_key3] = arguments[_key3];\n  }\n\n  function validate(node, key, val) {\n    var _iterator2 = _createForOfIteratorHelper(types),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var type = _step2.value;\n\n        if (getType(val) === type || (0, _is[\"default\"])(type, val)) {\n          (0, _validate.validateChild)(node, key, val);\n          return;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    throw new TypeError(\"Property \".concat(key, \" of \").concat(node.type, \" expected node to be of a type \").concat(JSON.stringify(types), \" but instead got \").concat(JSON.stringify(val == null ? void 0 : val.type)));\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\n\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    var valid = getType(val) === type;\n\n    if (!valid) {\n      throw new TypeError(\"Property \".concat(key, \" expected type of \").concat(type, \" but got \").concat(getType(val)));\n    }\n  }\n\n  validate.type = type;\n  return validate;\n}\n\nfunction assertShape(shape) {\n  function validate(node, key, val) {\n    var errors = [];\n\n    for (var _i = 0, _Object$keys = Object.keys(shape); _i < _Object$keys.length; _i++) {\n      var property = _Object$keys[_i];\n\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n\n        throw error;\n      }\n    }\n\n    if (errors.length) {\n      throw new TypeError(\"Property \".concat(key, \" of \").concat(node.type, \" expected to have the following:\\n\").concat(errors.join(\"\\n\")));\n    }\n  }\n\n  validate.shapeOf = shape;\n  return validate;\n}\n\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n\n    var current = node;\n\n    while (node) {\n      var _current2 = current,\n          type = _current2.type;\n\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(\"Non-optional \".concat(node.type, \" must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from \").concat((_current = current) == null ? void 0 : _current.type));\n  }\n\n  return validate;\n}\n\nfunction chain() {\n  for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    fns[_key4] = arguments[_key4];\n  }\n\n  function validate() {\n    var _iterator3 = _createForOfIteratorHelper(fns),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var fn = _step3.value;\n        fn.apply(void 0, arguments);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  validate.chainOf = fns;\n\n  if (fns.length >= 2 && \"type\" in fns[0] && fns[0].type === \"array\" && !(\"each\" in fns[1])) {\n    throw new Error(\"An assertValueType(\\\"array\\\") validator can only be followed by an assertEach(...) validator.\");\n  }\n\n  return validate;\n}\n\nvar validTypeOpts = [\"aliases\", \"builder\", \"deprecatedAlias\", \"fields\", \"inherits\", \"visitor\", \"validate\"];\nvar validFieldKeys = [\"default\", \"optional\", \"validate\"];\n\nfunction defineAliasedType() {\n  for (var _len5 = arguments.length, aliases = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    aliases[_key5] = arguments[_key5];\n  }\n\n  return function (type) {\n    var _defined2;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var defined = opts.aliases;\n\n    if (!defined) {\n      var _store$opts$inherits$, _defined;\n\n      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();\n      (_defined = defined) != null ? _defined : defined = [];\n      opts.aliases = defined;\n    }\n\n    var additional = aliases.filter(function (a) {\n      return !defined.includes(a);\n    });\n\n    (_defined2 = defined).unshift.apply(_defined2, _toConsumableArray(additional));\n\n    return defineType(type, opts);\n  };\n}\n\nfunction defineType(type) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var inherits = opts.inherits && store[opts.inherits] || {};\n  var fields = opts.fields;\n\n  if (!fields) {\n    fields = {};\n\n    if (inherits.fields) {\n      var keys = Object.getOwnPropertyNames(inherits.fields);\n\n      var _iterator4 = _createForOfIteratorHelper(keys),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var key = _step4.value;\n          var field = inherits.fields[key];\n          var def = field[\"default\"];\n\n          if (Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\") {\n            throw new Error(\"field defaults can only be primitives or empty arrays currently\");\n          }\n\n          fields[key] = {\n            \"default\": Array.isArray(def) ? [] : def,\n            optional: field.optional,\n            validate: field.validate\n          };\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }\n\n  var visitor = opts.visitor || inherits.visitor || [];\n  var aliases = opts.aliases || inherits.aliases || [];\n  var builder = opts.builder || inherits.builder || opts.visitor || [];\n\n  for (var _i2 = 0, _Object$keys2 = Object.keys(opts); _i2 < _Object$keys2.length; _i2++) {\n    var k = _Object$keys2[_i2];\n\n    if (validTypeOpts.indexOf(k) === -1) {\n      throw new Error(\"Unknown type option \\\"\".concat(k, \"\\\" on \").concat(type));\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(visitor.concat(builder)),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _key7 = _step5.value;\n      fields[_key7] = fields[_key7] || {};\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  for (var _i3 = 0, _Object$keys3 = Object.keys(fields); _i3 < _Object$keys3.length; _i3++) {\n    var _key6 = _Object$keys3[_i3];\n    var _field = fields[_key6];\n\n    if (_field[\"default\"] !== undefined && builder.indexOf(_key6) === -1) {\n      _field.optional = true;\n    }\n\n    if (_field[\"default\"] === undefined) {\n      _field[\"default\"] = null;\n    } else if (!_field.validate && _field[\"default\"] != null) {\n      _field.validate = assertValueType(getType(_field[\"default\"]));\n    }\n\n    for (var _i4 = 0, _Object$keys4 = Object.keys(_field); _i4 < _Object$keys4.length; _i4++) {\n      var _k = _Object$keys4[_i4];\n\n      if (validFieldKeys.indexOf(_k) === -1) {\n        throw new Error(\"Unknown field key \\\"\".concat(_k, \"\\\" on \").concat(type, \".\").concat(_key6));\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(function (alias) {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n\n  store[type] = opts;\n}\n\nvar store = {};","map":null,"metadata":{},"sourceType":"script"}