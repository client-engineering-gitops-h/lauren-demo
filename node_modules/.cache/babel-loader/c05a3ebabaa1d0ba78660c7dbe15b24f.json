{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { AbstractPureComponent2, Classes, Keys } from \"../../common\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp } from \"../../common/utils\";\nimport { Browser } from \"../../compatibility\";\nvar BUFFER_WIDTH_DEFAULT = 5;\nvar BUFFER_WIDTH_IE = 30;\n\nvar EditableText =\n/** @class */\nfunction (_super) {\n  __extends(EditableText, _super);\n\n  function EditableText(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.inputElement = null;\n    _this.valueElement = null;\n    _this.refHandlers = {\n      content: function content(spanElement) {\n        _this.valueElement = spanElement;\n      },\n      input: function input(_input) {\n        if (_input != null) {\n          _this.inputElement = _input; // temporary fix for #3882\n\n          if (!_this.props.alwaysRenderInput) {\n            _this.inputElement.focus();\n          }\n\n          if (_this.state != null && _this.state.isEditing) {\n            var supportsSelection = inputSupportsSelection(_input);\n\n            if (supportsSelection) {\n              var length_1 = _input.value.length;\n\n              _input.setSelectionRange(_this.props.selectAllOnFocus ? 0 : length_1, length_1);\n            }\n\n            if (!supportsSelection || !_this.props.selectAllOnFocus) {\n              _input.scrollLeft = _input.scrollWidth;\n            }\n          }\n        }\n      }\n    };\n\n    _this.cancelEditing = function () {\n      var _a, _b, _c, _d;\n\n      var _e = _this.state,\n          lastValue = _e.lastValue,\n          value = _e.value;\n\n      _this.setState({\n        isEditing: false,\n        value: lastValue\n      });\n\n      if (value !== lastValue) {\n        (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, lastValue);\n      }\n\n      (_d = (_c = _this.props).onCancel) === null || _d === void 0 ? void 0 : _d.call(_c, lastValue);\n    };\n\n    _this.toggleEditing = function () {\n      var _a, _b;\n\n      if (_this.state.isEditing) {\n        var value = _this.state.value;\n\n        _this.setState({\n          isEditing: false,\n          lastValue: value\n        });\n\n        (_b = (_a = _this.props).onConfirm) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n      } else if (!_this.props.disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n    };\n\n    _this.handleFocus = function () {\n      var _a = _this.props,\n          alwaysRenderInput = _a.alwaysRenderInput,\n          disabled = _a.disabled,\n          selectAllOnFocus = _a.selectAllOnFocus;\n\n      if (!disabled) {\n        _this.setState({\n          isEditing: true\n        });\n      }\n\n      if (alwaysRenderInput && selectAllOnFocus && _this.inputElement != null) {\n        var length_2 = _this.inputElement.value.length;\n\n        _this.inputElement.setSelectionRange(0, length_2);\n      }\n    };\n\n    _this.handleTextChange = function (event) {\n      var _a, _b;\n\n      var value = event.target.value; // state value should be updated only when uncontrolled\n\n      if (_this.props.value == null) {\n        _this.setState({\n          value: value\n        });\n      }\n\n      (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n    };\n\n    _this.handleKeyEvent = function (event) {\n      // HACKHACK: https://github.com/palantir/blueprint/issues/4165\n\n      /* eslint-disable-next-line deprecation/deprecation */\n      var altKey = event.altKey,\n          ctrlKey = event.ctrlKey,\n          metaKey = event.metaKey,\n          shiftKey = event.shiftKey,\n          which = event.which;\n\n      if (which === Keys.ESCAPE) {\n        _this.cancelEditing();\n\n        return;\n      }\n\n      var hasModifierKey = altKey || ctrlKey || metaKey || shiftKey;\n\n      if (which === Keys.ENTER) {\n        // prevent IE11 from full screening with alt + enter\n        // shift + enter adds a newline by default\n        if (altKey || shiftKey) {\n          event.preventDefault();\n        }\n\n        if (_this.props.confirmOnEnterKey && _this.props.multiline) {\n          if (event.target != null && hasModifierKey) {\n            insertAtCaret(event.target, \"\\n\");\n\n            _this.handleTextChange(event);\n          } else {\n            _this.toggleEditing();\n          }\n        } else if (!_this.props.multiline || hasModifierKey) {\n          _this.toggleEditing();\n        }\n      }\n    };\n\n    var value = props.value == null ? props.defaultValue : props.value;\n    _this.state = {\n      inputHeight: 0,\n      inputWidth: 0,\n      isEditing: props.isEditing === true && props.disabled === false,\n      lastValue: value,\n      value: value\n    };\n    return _this;\n  }\n\n  EditableText.prototype.render = function () {\n    var _a;\n\n    var _b;\n\n    var _c = this.props,\n        alwaysRenderInput = _c.alwaysRenderInput,\n        disabled = _c.disabled,\n        multiline = _c.multiline,\n        contentId = _c.contentId;\n    var value = (_b = this.props.value) !== null && _b !== void 0 ? _b : this.state.value;\n    var hasValue = value != null && value !== \"\";\n    var classes = classNames(Classes.EDITABLE_TEXT, Classes.intentClass(this.props.intent), (_a = {}, _a[Classes.DISABLED] = disabled, _a[Classes.EDITABLE_TEXT_EDITING] = this.state.isEditing, _a[Classes.EDITABLE_TEXT_PLACEHOLDER] = !hasValue, _a[Classes.MULTILINE] = multiline, _a), this.props.className);\n    var contentStyle;\n\n    if (multiline) {\n      // set height only in multiline mode when not editing\n      // otherwise we're measuring this element to determine appropriate height of text\n      contentStyle = {\n        height: !this.state.isEditing ? this.state.inputHeight : undefined\n      };\n    } else {\n      // minWidth only applies in single line mode (multiline == width 100%)\n      contentStyle = {\n        height: this.state.inputHeight,\n        lineHeight: this.state.inputHeight != null ? this.state.inputHeight + \"px\" : undefined,\n        minWidth: this.props.minWidth\n      };\n    } // If we are always rendering an input, then NEVER make the container div focusable.\n    // Otherwise, make container div focusable when not editing, so it can still be tabbed\n    // to focus (when the input is rendered, it is itself focusable so container div doesn't need to be)\n\n\n    var tabIndex = alwaysRenderInput || this.state.isEditing || disabled ? undefined : 0; // we need the contents to be rendered while editing so that we can measure their height\n    // and size the container element responsively\n\n    var shouldHideContents = alwaysRenderInput && !this.state.isEditing;\n    var spanProps = contentId != null ? {\n      id: contentId\n    } : {};\n    return React.createElement(\"div\", {\n      className: classes,\n      onFocus: this.handleFocus,\n      tabIndex: tabIndex\n    }, alwaysRenderInput || this.state.isEditing ? this.renderInput(value) : undefined, shouldHideContents ? undefined : React.createElement(\"span\", __assign({}, spanProps, {\n      className: Classes.EDITABLE_TEXT_CONTENT,\n      ref: this.refHandlers.content,\n      style: contentStyle\n    }), hasValue ? value : this.props.placeholder));\n  };\n\n  EditableText.prototype.componentDidMount = function () {\n    this.updateInputDimensions();\n  };\n\n  EditableText.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a, _b;\n\n    var newState = {}; // allow setting the value to undefined/null in controlled mode\n\n    if (this.props.value !== prevProps.value && (prevProps.value != null || this.props.value != null)) {\n      newState.value = this.props.value;\n    }\n\n    if (this.props.isEditing != null && this.props.isEditing !== prevProps.isEditing) {\n      newState.isEditing = this.props.isEditing;\n    }\n\n    if (this.props.disabled || this.props.disabled == null && prevProps.disabled) {\n      newState.isEditing = false;\n    }\n\n    this.setState(newState);\n\n    if (this.state.isEditing && !prevState.isEditing) {\n      (_b = (_a = this.props).onEdit) === null || _b === void 0 ? void 0 : _b.call(_a, this.state.value);\n    } // updateInputDimensions is an expensive method. Call it only when the props\n    // it depends on change\n\n\n    if (this.state.value !== prevState.value || this.props.alwaysRenderInput !== prevProps.alwaysRenderInput || this.props.maxLines !== prevProps.maxLines || this.props.minLines !== prevProps.minLines || this.props.minWidth !== prevProps.minWidth || this.props.multiline !== prevProps.multiline) {\n      this.updateInputDimensions();\n    }\n  };\n\n  EditableText.prototype.renderInput = function (value) {\n    var _a = this.props,\n        disabled = _a.disabled,\n        maxLength = _a.maxLength,\n        multiline = _a.multiline,\n        type = _a.type,\n        placeholder = _a.placeholder;\n    var props = {\n      className: Classes.EDITABLE_TEXT_INPUT,\n      disabled: disabled,\n      maxLength: maxLength,\n      onBlur: this.toggleEditing,\n      onChange: this.handleTextChange,\n      onKeyDown: this.handleKeyEvent,\n      placeholder: placeholder,\n      value: value\n    };\n    var _b = this.state,\n        inputHeight = _b.inputHeight,\n        inputWidth = _b.inputWidth;\n\n    if (inputHeight !== 0 && inputWidth !== 0) {\n      props.style = {\n        height: inputHeight,\n        lineHeight: !multiline && inputHeight != null ? inputHeight + \"px\" : undefined,\n        width: multiline ? \"100%\" : inputWidth\n      };\n    }\n\n    return multiline ? React.createElement(\"textarea\", __assign({\n      ref: this.refHandlers.input\n    }, props)) : React.createElement(\"input\", __assign({\n      ref: this.refHandlers.input,\n      type: type\n    }, props));\n  };\n\n  EditableText.prototype.updateInputDimensions = function () {\n    if (this.valueElement != null) {\n      var _a = this.props,\n          maxLines = _a.maxLines,\n          minLines = _a.minLines,\n          minWidth = _a.minWidth,\n          multiline = _a.multiline;\n      var _b = this.valueElement,\n          parentElement_1 = _b.parentElement,\n          textContent = _b.textContent;\n      var _c = this.valueElement,\n          scrollHeight_1 = _c.scrollHeight,\n          scrollWidth = _c.scrollWidth;\n      var lineHeight = getLineHeight(this.valueElement); // add one line to computed <span> height if text ends in newline\n      // because <span> collapses that trailing whitespace but <textarea> shows it\n\n      if (multiline && this.state.isEditing && /\\n$/.test(textContent !== null && textContent !== void 0 ? textContent : \"\")) {\n        scrollHeight_1 += lineHeight;\n      }\n\n      if (lineHeight > 0) {\n        // line height could be 0 if the isNaN block from getLineHeight kicks in\n        scrollHeight_1 = clamp(scrollHeight_1, minLines * lineHeight, maxLines * lineHeight);\n      } // Chrome's input caret height misaligns text so the line-height must be larger than font-size.\n      // The computed scrollHeight must also account for a larger inherited line-height from the parent.\n\n\n      scrollHeight_1 = Math.max(scrollHeight_1, getFontSize(this.valueElement) + 1, getLineHeight(parentElement_1)); // Need to add a small buffer so text does not shift prior to resizing, causing an infinite loop.\n      // IE needs a larger buffer than other browsers.\n\n      scrollWidth += Browser.isInternetExplorer() ? BUFFER_WIDTH_IE : BUFFER_WIDTH_DEFAULT;\n      this.setState({\n        inputHeight: scrollHeight_1,\n        inputWidth: Math.max(scrollWidth, minWidth)\n      }); // synchronizes the ::before pseudo-element's height while editing for Chrome 53\n\n      if (multiline && this.state.isEditing) {\n        this.setTimeout(function () {\n          return parentElement_1.style.height = scrollHeight_1 + \"px\";\n        });\n      }\n    }\n  };\n\n  EditableText.displayName = DISPLAYNAME_PREFIX + \".EditableText\";\n  EditableText.defaultProps = {\n    alwaysRenderInput: false,\n    confirmOnEnterKey: false,\n    defaultValue: \"\",\n    disabled: false,\n    maxLines: Infinity,\n    minLines: 1,\n    minWidth: 80,\n    multiline: false,\n    placeholder: \"Click to Edit\",\n    type: \"text\"\n  };\n  EditableText = __decorate([polyfill], EditableText);\n  return EditableText;\n}(AbstractPureComponent2);\n\nexport { EditableText };\n\nfunction getFontSize(element) {\n  var fontSize = getComputedStyle(element).fontSize;\n  return fontSize === \"\" ? 0 : parseInt(fontSize.slice(0, -2), 10);\n}\n\nfunction getLineHeight(element) {\n  // getComputedStyle() => 18.0001px => 18\n  var lineHeight = parseInt(getComputedStyle(element).lineHeight.slice(0, -2), 10); // this check will be true if line-height is a keyword like \"normal\"\n\n  if (isNaN(lineHeight)) {\n    // @see http://stackoverflow.com/a/18430767/6342931\n    var line = document.createElement(\"span\");\n    line.innerHTML = \"<br>\";\n    element.appendChild(line);\n    var singleLineHeight = element.offsetHeight;\n    line.innerHTML = \"<br><br>\";\n    var doubleLineHeight = element.offsetHeight;\n    element.removeChild(line); // this can return 0 in edge cases\n\n    lineHeight = doubleLineHeight - singleLineHeight;\n  }\n\n  return lineHeight;\n}\n\nfunction insertAtCaret(el, text) {\n  var selectionEnd = el.selectionEnd,\n      selectionStart = el.selectionStart,\n      value = el.value;\n\n  if (selectionStart >= 0) {\n    var before_1 = value.substring(0, selectionStart);\n    var after_1 = value.substring(selectionEnd, value.length);\n    var len = text.length;\n    el.value = \"\" + before_1 + text + after_1;\n    el.selectionStart = selectionStart + len;\n    el.selectionEnd = selectionStart + len;\n  }\n}\n\nfunction inputSupportsSelection(input) {\n  switch (input.type) {\n    // HTMLTextAreaElement\n    case \"textarea\":\n      return true;\n    // HTMLInputElement\n    // see https://html.spec.whatwg.org/multipage/input.html#do-not-apply\n\n    case \"text\":\n    case \"search\":\n    case \"tel\":\n    case \"url\":\n    case \"password\":\n      return true;\n\n    default:\n      return false;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}